## 32. 동기와 비동기

동기?
여러개의 작업이 있을때, 한번에 하나씩만 처리하는 방식 
Task A  실행 -> Task A 종료 ->
Task B 실행 -> Task B 종료

이렇게 직접 작업을 실행하고 처리해주는 역항릉 하는 것을 스레드(Thread)라고 한다. 

-> 여러개의 작업을 순서대로 하나씩 처리하는 프로그램 실행 방식 

---
자바스크립트 엔진은 특별한 함수를 사용해서 비동기적으로 동작하도록 설정한 게 아니라면, 
모든 코드는 동기적으로 동작한다. 
그럼에도 비동기적으로 여러개의 코드를 한번에 실행하는 것처럼 보이는 이유는, 
비동기 작업들은 자바스크립트 엔진에 있는 스레드가 실행하는게 아니라, Web APIs 라는 브라우저가 직접 관리하는 별도의 공간에서 따로 실행이 되기 때문이다. 
Web APIs 라는건 웹 브라우저가 직접 관리하는 별도의 영역을 말한다. 
이 영역이 실제 비동기 작업이 실행되는 영역이다. 한 줄 씩 차례대로 실행하다가, 비동기 작업을 만나면 Web APIs에게 요청, 그리고 차례대로 작업을 이어가다가, 타이머가 끝나면 실행할 전달받았던 콜백함수를 Web APIs가 넘겨준다(시간이 다 되었으니, 이제 실행해)
자바스크립트 엔진은 그제서야 콜백함수를 실행시키믕로써 비동기 처리가 이루어지게 된다. 

자바스크립트 엔진은 web APIs라는 브라우저의 별도 영역 또는 별도 기능을 활용해서 비동기 처리를 진행하기 때문에, 스레드가 하나밖에 없음에도 여러개의 작업을 동시에 처리할 수 있는 것이다. 

## 33. 비동기 작업 처리하기1-콜백함수 
비동기 데이터를 가지고 또 다른 함수를 호출해야 할때, 계속해서 콜백의 값을 새로운 함수에 넣다보면 콜백지옥이 일어날 수 있다.
이는 가독성에도 영향을 주고 코드 유지보수에도 좋지 않다. 
### 콜백지옥이 안좋은 이유? 

이러한 콜백 지옥을 회피하기 위해서 Promise라는 비동기 작업을 도와주는 객체를 이용한다. 

## 34. 비동기 작업 처리하기2-Promise
Promise는 마치 날짜를 저장하는 Date 객체처럼, 특수한 목적을 위해서 존재하는 자바스크립트의 내장객체를 말한다. 
비동기 작업을 실행하고, 그 결과를 처리하는 코드를 좀 더 효율적이고 편하게 작성할 수 있도록 도와준다. 

예를 들면 setTimeout과 같은 비동기 작업들을 랩핑하는, 객체이다. 이렇게 감싸고 있는 비동기 작업을 실행시켜주거나, 현재의 상태를 관리하거나 또는 심지어 여러개의 작업을 병렬로 동시에 실행시켜주거나, 다시 실행시켜주는 비동기 작업을 처리하는데 필요한 모든 기능을 제공해준다고 보면 된다. 

'Promise는 비동기 작업을 감싸는 객체이다.'

[비동기 작업 실행]
Promise는 비동기 작업을 진행 단계에 따라 세 단계로 나누어서 관리한다. 
각각의 상태를 보면, 
- 대기(Pending) : 아직 비동기 작업이 진행중인, 완료되지 않은 상태
- 성공(Fullfilled) : 비동기 작업이 별다른 오류 없이 성공적으로 마무리된 상태
- 실패(Rejected) : 비동기 작업이 모종의 이유로 실패된 상태

이때, 어떠한 비동기 작업이 대기 상태에서 작업이 성공적으로 완료되어 성공 상태로 바뀌는 것을 resolved되었다고 표현하고, 
반대로, 어떤 이유로 비동기 작업이 대기 상태였다가 실패 상태로 바뀌는 것은 거부되었다는 의미에서 rejected라고 표현한다. 


[비동기 작업 상태 관리]
promise는 생성자를 이용해서 생성해준다.
생성자의 인수로 비동기 작업을 실제로 진행할 callback 함수를 넣어주면 된다. 그러면 promise 객체가 생성됨과 동시에
callback함수를 호출해서 안에 있는 비동기 작업들을 실행해준다. 그렇기 때문에, 이 콜백함수를 특별히 실제로 비동기 작업을 실행하는 함수다 라는 의미에서 Executer라고 부른다. 
```
const promise = new Promise();
console.log(promise)
```
console에서 promise를 찍어보면, 프로미스 객체가 출력된다. 이렇게 출력된 프로미스의 객체의 내부 프로퍼티를 보면, 
현재 상태는 pending, 즉 결과값은 아직 대기 상태로 PromiseResult의 값은 undefined가 보인다.

Executer 함수에는 두 가지 매개변수가 각각 전달이 된다. resolved, rejected
- resolved : 비동기 작업을 성공 상태로 바꾸는 함수
- rejected : 비동기 작업을 실패 상태로 바꾸는 함수

[비동기 작업 결과 저장]
만약 어떠한 비동기 작업을 성공 상태로 변경하려면 
```
const promise = new Promise((resolve, reject)=> {
    setTimeout(()=> {
        resolve() // 성공 상태지만 PromiseResult의 값은 여전히 undefined 상태
        resolve('안녕') // 성공 상태이고, PromiseResult의 값을 '안녕'으로 전달 
    }, 1000)

})
```
이렇게 resolve 함수를 호출해주면 된다.(reject도 마찬가지)
차이점은 reject가 넘겨주는 인수는 에러 메세지로 출력됨. 

### Promise로 생성된 결과값을 이용하려면 

[Promise Chaining]
Promise 객체의 메서드인 then이라는 메서드를 호출해야 한다. 
```
promise.then((message)=> {
    // promise가 resolved 상태가 되었을때, 여기로 온다. 이때 가지게 되는 매개변수가 promise의 성공한 PromiseResult 값을 가지게 
    된다.
    // promise의 결과값이 성공상태일때 실행되는 콜백함수
}).catc((errorMsg)=> {
    // promise가 reject 상태가 되었을 때, 이때의 결과값을 가지게 된다. 
    // 즉, promise가 실패상태일때 실행되는 콜백함수
})
```
이렇게 하나로 쓸 수 있는 이유는, promise의 then 반환 결과는 또 하나의 promise를 반환하기 때문이다. 
이렇게 사용하는 것을 Promise Chaining 이라고 한다. 

[콜백지옥 탈출하기]

```
add10(0)
.then((result)=> {
    return add10(result)
})
.then((result)=> {
    return add10(result)
})
.catch((error)=> {
    console.log(error)
})
```
promise는 resolve, reject를 반환할 수도 있지만, 또 하나의 promise인 promise를 return 할 수도 있다. 
return 된 promise는 promise의 결과값을 가진다.
이 promise 객체는 자바스크립트의 개념들 중에 가장 중요한 개념일 것이다. 
예를 들어서 API를 호출한다거나, 다른 서버와 통신 이런데 사용될 수 있음. 

## 35. 비동기 작업 처리하기3-async await 
Promise를 좀 더 직관적이고 편하게 사용할 수 있는 문법이 있다. 
- async : 함수 앞에 붙이는 키워드. 함수를 비동기 함수로 만들어준다. 
=> 함수가 promise를 반환하도록 변환해주는 키워드이다. 

```
async funtion getData(){
    return {
        name : '고은', 
        id: 144
    }
}
```
이렇게 선언하게 되면 이 getData()의 반환 값은 Object가 아닌, Promise객체를 반환하게 된다는 것이다. 
그리고 PromiseResult에 해당 값을 결과 값으로 가지게 된다. 그런데 함수 내부의 내용 자체가 그냥 Object를 반환하는 것이 아닌, Promise 형태의 애초 promise를 반환하는 함수였다면, 
별다른 기능을 하지 않고 이 promise 객체 자체를 반환하도록 그냥 내버려둔다. 
=> async 함수는 프로미스를 반환하지 않는 함수에 붙여서 자동으로 해당 함수를 비동기로 작동하도록 변환하는 그런 기능을 한다. 

### await과 함께 사용할때 그 위력이 발휘된다. 
await이라는 키워드는 asnyc 함수 내부에서만 사용이 가능한 키워드이다. async 비동기 함수가 다 처리되기를 기다리는 역할을 하는 키워드이다. 

```
getData().then(()=> {

})
대신에 
await getData() 
```
이렇게 작성할 수 있다는것. promise가 종료될 때까지 기다려준다.
프로미스의 비동기 작업이 종료되기까지 기다렸다가 종료가 되면 결과 값을 넣어주는 기능을 하게 된다. 

### async/await을 사용하면 비동기 함수를 동기처럼 작성할 수 있다. 
await 함수는 async가 붙지 않은 함수에서 사용할 경우 오류가 발생한다. 