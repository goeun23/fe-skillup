# SOLID 원칙

## Single Responsibility Principle(SRP)

> 단일책임원칙- 하나의 클래스는 하나의 책임만 가져야 한다.

- 특징

  - 변경 사유가 하나 뿐이어야 한다.
  - 역할이 많아질수록 변경시 영향을 많이 받기 때문이다.
    ex. ReportPrinter는 출력만, ReportGenerator는 생성만 담당

- 한 객체는 하나의 책임만 가져야 한다.
- 책임 = 변경의 이유
- 객체가 너무 많아지므로 지키지 않는 경우도 많음

## Open Closed Principle(OCP)

> 개방폐쇄원칙-기능은 확장에 열려 있고, 기존 코드는 변경에 닫혀있어야 한다.

- 새로운 기능 추가 시 기존 코드를 수정 없이 기능 추가가 가능하다.
- > 기존 로직의 안정성 유지
- ex. 전략 패턴으로 결제수단 확장 가능

- 확장에 대해서는 열려있고, 변경에 대해서는 닫혀있어야 한다.
- 새로운 기능을 추가할 때 기존 코드가 수정되면 안된다.

## Liskov Substitution Principle(LSP)

> 리스코프 치환원칙 - 상위 타입 객체를 하위 타입으로 바꿔도 프로그램이 정상 작동해야 한다.

- 하위 클래스는 사우이 클래스의 동작 계약을 꺠면 안된다.
- > 다형성 유지
- ex. Bird를 상속한 Penguin이 fly()를 덮어쓰고 예외를 던지는 경우 위반

- 자식 클래스는 부모클래스의 역할을 대체할 수 있어야 한다.
- 부모 클래스의 자리에 자식 클래스를 넣고 타입 에러가 나나 확인해 보면 됨

## Interface Segregation Principle(ISP)

> 인터페이스 분리 원칙 - 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안된다.

- 인터페이스는 작고 명확하게 구성한다.
- > 거대한 인터페이스는 불필요한 구현을 강제한다.
- ex. Print, Scan, Fax를 하나의 Machine 인터페이스로 묶지 않고 각각 나눈다.

- 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야한다.
- 인터페이스의 단일 책임 원칙
- 인터페이스를 쪼개서 여러 개로 만들고, 필요한 만큼 implements

## Dependency Inversion Principle(DIP)

> 의존성 역전 원칙 - 상위 모듈은 하위 모듈에의존하지 않고, 둘 다 추상에 의존해야 한다.

- 구현보다 인터페이스(추상)에 의존한다.
- > 구체 구현 변경시 상위 코드 영향 제거
- ex. PaymentService는 IPaymentMethod에 의존, 실제 구현은 외부에서 주입한다.

- 추상성이 높은 클래스와 의존 관계를 맺는다.
- 상속 대신 합성을 하자.
- interfce, abstract class를 매개변수로 받자.
