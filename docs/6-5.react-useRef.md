# useRef

- useRefernce의 줄임말로, 컴포넌트 내부에 새로운 레퍼런스 객체를 생성해주는 기능
- 이렇게 생성한 레퍼런스 객체는 컴포넌트의 내부 변수로서 일반적인 값을 저장할 수 있다.

## useRef / useState

두 기능 모두 컴포넌트 내부에서 쓰고 싶은 변수를 생성한다는 점은 같다.

- useState는 값이 변경되었을 때 컴포넌트를 리렌더링 시킨다.
- useRef로 생성한 변수는 값이 변경되더라도 컴포넌트를 리렌더링 시키지 않는다.

그렇기 때문에 렌더링에 영향을 미치고 싶지 않은 변수를 생성할 때, 이 useRef를 사용하게 된다.
그리고 useRef를 이용하면 컴포넌트가 렌더링하는 특정 DOM 요소에 접근할 수 있다.
그럼으로서 해당 요소를 조작하는 것도 가능하다. (특정 요소에 focus를 준다거나 스타일을 줄 수 도 있음)

- useRef또한 리액트에서 제공되는 내장함수이기 때문에 'import {useRef} from 'react' 구문으로 불러온다.

```
const refObj = useRef();
```

콘솔에서 확인해보면, current라는 프로퍼티를 갖는 객체가 출력된다. 결국 이 레퍼런스 객체란, 이 current라는 프로퍼티에 현재 보관할 값을 담아두기만 하는 단순한 자바스크립트 객체이다.

```
const refObj = useRef(0);
// current:0이 담기게 된다.
```

객체의 값을 사용하려면 'refObj.current' 이렇게 사용하면 된다.
레퍼런스 객체는 리렌더링을 일으키지 않기 떄문에, 이벤트는 발생하지만 화면에 아무런 변화도 일어나지 않는다. 이 레퍼런스 오브젝트는 컴포넌트 내부에서 렌더링에 영향을 미치지 않아야되는 변수를 생성할 때 사용할 수 있다.

- 활용 사례로는 수정 횟수같은 것을 내부적으로 체크할 때 사용해볼 수 있음.
- DOM 요소를 직접 조작할 떄 사용할 수 있음.

```
const inputRef = useRef();
<input
    useRef={inputRef}
/>
// focus를 주려면,
inputRef.current.focus()
```

### 그냥 전역변수와의 차이점

여러개의 컴포넌트를 선언해서 호출한다고 했을 때, 여러개의 컴포넌트가 하나의 전역 변수를 바라보게 된다. 여러개의 컴포넌트가 그냥 하나의 변수를 여러번 호출한 것과 같게 된다.
새로운 컴포넌트가 리렌더링될 때는 안에 있는 코드가 모두 다시 실행되는데, 이 때마다 계속 useRef를 초기화하는 코드를 지나기 때문에 계속 같은 초기 값을 가지게 되는 것이다.
그렇기 때문에 컴포넌트 내부의 변수가 필요하다면 let이 아닌 useRef를 사용하여 생성하는 것이 적절하다.
