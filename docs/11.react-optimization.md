# React 최적화

최적화 : 서비스의 성능을 개선하는 모든 행위

## 최적화가 필요한 이유

- 성능 문제로 인한 사용자 경험 저하:React 애플리케이션이 커질수록 렌더링 성능, 메모리 사용량, 번들 크기 등의 문제가 발생하여 사용자가 느린 반응성을 경험하게 된다.
- 비즈니스 영향 : 페이지 로딩 시간이 1초 늘어날 때마다 전환율이 7%감소하고, 모바일 사용자의 53%는 3초 이상 로딩되는 페이지를 떠난다는 연구 결과가 있다.

## useMemo

- useMemo라는 React Hook을 이용하여 내부에서 불필요한 연산을 다시 수행하지 않도록 최적화하는 기법
- 프로그래밍에서 동일한 연산을 반복적으로 수행해야 될 때 매번 결과값을 다시 계산하도록 만드는게 아니라 최초로 계산했을때의 결과값을 메모리 어딘가에 보관해둔 다음에, 다시 이 연산이 필요해지면 저장되어있던 결과값을 돌려주는 기법을 말한다.

- 메모이제이션 기법을 이용하면 최초의 한 번 연산을 수행해서, 결과값으,ㄹ 저장해 놓은 다음부터는 똑같은 연산을 불필요하게 수행할 필요가 없다.

- todo의 analizedData 함수는 search 바에서 검색할때는 다시 렌더링 될 필요가 없지만, 데이터가 변경되었음을 감지하여 렌더링을 다시 한다. 이건 분명한 낭비인 것. 이럴 때 useMemo를 이용하면 연산 자체를 메모이제이션할 수 있다. 그리고 특정 조건이 만족했을 때만 결과값을 다시 계산하도록 설정할 수도 있다.

```
useMemo(()=> {
    return {
        totalCount,
        doneCount...
    }
}, [totalCount, doneCount, ...])
```

- 여기서 두 번째 들어가는 deps의 값이 변경되었을 때만 콜백함수를 다시 실행한다. 그리고 첫번째 콜백함수가 반환하는 값을 deps가 가지게 된다.

- 여기서 deps를 빈 배열로 두면, 함수의 연산과 반환이 컴포넌트가 생성 될 때 딱 한 번 실행하게 된다.

## React.memo

리액트의 내장 메서드. 컴포넌트의 불필요한 렌더링을 막는 방법
인수로 react의 component를 받아서, 최적화 기능을 추가한 다음 결과값을 반환해준다. 이렇게 추가된 컴포넌트는 props를 기준으로 메모이제이션이 된다.

memoized Component는 부모 컴포넌트가 리렌더링 되더라도 자신이 받는 props가 바뀌지 않으면 다시는 리렌더링 되지 않도록 메모이제이션 되기 때문에 불필요한 리렌더링이 방지되어 최적화가 이루어지게 된다.

```
import memo from "react"
export default memo(Header)
```

그런데 이때, 함수는 객체 타입에 해당되는데, 새롭게 생성된 함수들이 같은 동작을 한다고 하더라도 새롭게 생성될 때마다 다른 값으로 인식하게 된다.
함수들은 모두 객체 타입에 해당하는 값이기 때문에 변수에는 주소값으로써 적용이 된다. 객체 비교는 주소값을 기반으로 수행한다. 내부 객체의 값이 일치한다 해도, 주소값이 다르기 때문에 리렌더링 되면서 매번 다른 값으로 판단되어 렌더링이 다시 일어나게 된다.

onDelete, onUpdate는 함수 형태로, 매번 다른 주소값을 가지기 때문에 계속 리렌더링이 일어나고 있기 때문에 memo 메서드를 사용하더라도 매번 새로운 주소값을 가지기 때문에 매번 다시 렌더링하고 있는것(얕은 비교를 이용한다.)
-> Todo 아이템들에서도 memo 메서드가 적용되었지만, 결국 모두 다 리렌더링이 발생하고 있었던 것이다.

여기서 해결할 수 있는 방법은 두가지가 있다.

1. 앱 컴포넌트에서 이 함수들 자체를 memoization 해서 리렌더링이 되더라도 다시 생성되지 않게 방지한다. (useCallback)

2. memo()함수 안에 두번째 인수로 콜백함수를 추가로 전달해서 최적화 기능을 customizing 해준다.

```
memo(TodoItem, (prevProps, nextProps)=> {
    // 반환값이 true를 가지면 props 리렌더링이 일어나지 않고,
    // 반환값이 false를 가지면 props 리렌더링이 일어나게 된다.
    if(prevProps.id === nextProps.id){
        return true;
    } // 이런 식으로 조건을 custom 할 수 있다.
})
```

이렇게 컴포넌트를 인수로 받아서 해당 컴포넌트에 최적화나 memoization 같은 추가적인 기능이 추가된 새로운 컴포넌트를 반환해주는 method들을 고차 함수 컴포넌트, Higher Order Component, HOC라고 부른다. 이 고차 컴포넌트를 이용하면 한번 호출하는 것만으로도 컴포넌트에 새로운 기능을 부여할 수 있기 때문에 복잡한 리액트 앱을 구축할때 많이 사용하는 방법이다.

## useCallback

2번 방식이 코드가 복잡해질 때는 귀찮은 일이 된다. 그래서 애초에 다시 생성되지 않도록 최적화하는게 좋은 방법이 될 수 있다.

```
useCallback(()=> {}, [])
const onDelete = useCallback((targetId)=> {
    dispatch({
        type...
    })
}, [])
```

즉, 함수를 memoization한다.

# 최적화의 기준

최적화는 언제 진행할까? 어떤것을 최적화할까
너무 이른 타이밍에 최적화를 해도 문제가 될 수 있고, 너무 많은 것을 최적화해도 문제가 될 수 있다. 그래서 보통 하나의 앱을 완성하고 나서 최적화를 진행하게 된다. 기능 구현이 먼저가 되어야 하고, 기능이 완성되면 그 뒤에 최적화를 진행하는게 일반적인 방법이다.
최적화를 위해서 useCallback 같은 메서드들을 적용해놓고 나면 새로운 기능을 덧붙이서나 기능을 수정해야 될때 최적화가 풀리게 되면, 아니면 아예 고장나게 되어버리는 경우도 생길 수 있다. 되도록이면 기능 구현을 먼저하고 마지막에 최적화를 진행하는 것을 권장한다.

## 어떤 것을 최적화할까

모든 것들에 최적화를 적용하면 안된다. 꼭 최적화가 필요할 것 같은 연산, 함수, 컴포넌트에만 최적화를 적용하는 것이 좋다. 예를 들면 Header 컴포넌트를 memo 메서드를 이용해서 최적화했는데, memo 메서드도 당연히 연산을 필요로하는 메서드이다. 이를테면 props의 값을 비교한다던가, 메모이제이션을 위해서 메모리에 컴포넌트의 결과값을 저장해놓는, 그런 기능들이 필요한데, 그렇게 최적화하는 컴포넌트가 그냥 UI를 렌더링하는 컴포넌트였다면, 그냥 다시 리렌더링 시키는게 더 빠를 수도 있다.
그래서 사소한 컴포넌트들까지 다 최적화를 진행하지는 않고, Todo Item 처럼 유저의 행동에 따라서 개수가 굉장히 많아질 수 있는 컴포넌트라던가, 함수들을 굉장히 많이 가지고 있어서 코드가 무거운 컴포넌트들에 한해서만 최적화를 수행함을 권장한다.
즉, 꼭 최적화 해야할 것 같은 애들만 최적화 하는게 좋다.

# React.memo와 useMemo의 차이

React.memo는 컴포넌트 전체의 리렌더링을 방지하는 고차 컴포넌트(HOC)

- 부모 컴포넌트가 리렌더링되어도 props가 변경되지않았다면 자식 컴포넌트의 리렌더링을 건너 뛰는 것
- 최적화 대상 : Component Re-rendering
- 사용위치 : 컴포넌트 정의시
- 반환값 : memoization 된 컴포넌트
- 비교방식 : props 얕은 비교

useMemo는 특정 값의 재계산을 방지하는 Hook

- 값비싼 계산을 의존성이 변경될 떄만 수행하고, 그 결과를 memoization하는 것
- 최적화 대상 : 값 계산
- 사용위치 : 컴포넌트 내부
- 반환값 : memoization된 값
- 비교방식 : 의존성 배열 비교
  언제 사용해야 할까?

## React.memo 사용 시기

- 자식 컴포넌트가 자주 리렌더링되는 경우
- 컴포넌트가 동일한 props로 동일한 결과를 렌더링하는 경우
- 부모 컴포넌트가 자주 리렌더링되지만 자식의 props는 변경되지 않는 경우

## useMemo 사용 시기

- 매 렌더링마다 수행되는 값비싼 계산이 있는 경우
- 복잡한 객체나 배열을 생성하는 경우
- 자식 컴포넌트의 props로 전달되는 참조값을 안정화하려는 경우

## 주의사항

- React.memo: 얕은 비교를 수행하므로 객체나 배열 props의 내부 값이 변경되어도 참조가 같으면 리렌더링을 건너뛸 수 있습니다.
- useMemo: 의존성 배열을 정확히 지정하지 않으면 예상치 못한 버그가 발생할 수 있습니다.
- 두 기법 모두 메모리를 사용하므로 실제 성능 개선이 있는지 측정 후 적용하는 것이 좋습니다.
